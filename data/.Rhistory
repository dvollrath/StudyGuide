fig1
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, R0=1, A0=1, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/(R0^(lambda))
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
RA_time <- 1/z_time
gA <- theta/z_time
R_time <- R0*exp(gL*u)
lnA_time <- log(z_time)/(1-phi) + lambda*log(R_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "R" = R_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "R_init" = R0, "A_init" = A0, "conv" = exp(-1*conv*u))
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
r <- f.romer(t = seq(from = 1,to = 200, by = 1))
s <- f.romer(t = seq(from = 1,to = 200, by = 1),A0 = r$A_init, R0 = r$R_init,gL = 0.002)
fig1 <- plot_ly(r, x = ~time, y = ~lnA, type = 'scatter', mode = 'lines', name='A')
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = s, name = 'B', mode = 'lines',
line = list(color = 'green'))
fig1
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, R0=1, A0=1, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/(R0^(lambda))
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
RA_time <- 1/z_time
gA <- theta/z_time
R_time <- R0*exp(gL*u)
lnA_time <- log(z_time)/(1-phi) + lambda*log(R_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "R" = R_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "R_init" = R0, "A_init" = A0, "conv" = exp(-1*conv*u))
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
r <- f.romer(t = seq(from = 1,to = 200, by = 1))
s <- f.romer(t = seq(from = 1,to = 200, by = 1),A0 = r$A_init, R0 = r$R_init,gL = 0.002)
fig1 <- plot_ly(r, x = ~time, y = ~gA, type = 'scatter', mode = 'lines', name='A')
fig1 <- fig1 %>% add_trace(x = ~time, y = ~gA, data = s, name = 'B', mode = 'lines',
line = list(color = 'green'))
fig1
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, L0=1, A0=1, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/((sR*L0)^(lambda))
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
LA_time <- 1/z_time
gA <- theta/z_time
L_time <- L0*exp(gL*u)
lnA_time <- lambda*log(sR)/(1-phi) + log(z_time)/(1-phi) + lambda*log(L_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "R" = R_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "R_init" = R0, "A_init" = A0, "conv" = exp(-1*conv*u))
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
r <- f.romer(t = seq(from = 1,to = 200, by = 1))
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, L0=1, A0=1, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/((sR*L0)^(lambda))
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
LA_time <- 1/z_time
gA <- theta/z_time
L_time <- L0*exp(gL*u)
lnA_time <- lambda*log(sR)/(1-phi) + log(z_time)/(1-phi) + lambda*log(L_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "L" = L_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "L_init" = L0, "A_init" = A0)
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
r <- f.romer(t = seq(from = 1,to = 200, by = 1))
s <- f.romer(t = seq(from = 1,to = 200, by = 1),A0 = r$A_init, R0 = r$R_init,gL = 0.002)
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, L0=1, A0=1, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/((sR*L0)^(lambda))
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
LA_time <- 1/z_time
gA <- theta/z_time
L_time <- L0*exp(gL*u)
lnA_time <- lambda*log(sR)/(1-phi) + log(z_time)/(1-phi) + lambda*log(L_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "L" = L_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "L_init" = L0, "A_init" = A0)
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
r <- f.romer(t = seq(from = 1,to = 200, by = 1))
s <- f.romer(t = seq(from = 1,to = 200, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.002)
fig1 <- plot_ly(r, x = ~time, y = ~gA, type = 'scatter', mode = 'lines', name='A')
fig1 <- fig1 %>% add_trace(x = ~time, y = ~gA, data = s, name = 'B', mode = 'lines',
line = list(color = 'green'))
fig1
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, L0=1, A0=1, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/((sR*L0)^(lambda))
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
LA_time <- 1/z_time
gA <- theta/z_time
L_time <- L0*exp(gL*u)
lnA_time <- lambda*log(sR)/(1-phi) + log(z_time)/(1-phi) + lambda*log(L_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "L" = L_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "L_init" = L0, "A_init" = A0)
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
r <- f.romer(t = seq(from = 1,to = 1000, by = 1))
s <- f.romer(t = seq(from = 1,to = 1000, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.002)
fig1 <- plot_ly(r, x = ~time, y = ~gA, type = 'scatter', mode = 'lines', name='A')
fig1 <- fig1 %>% add_trace(x = ~time, y = ~gA, data = s, name = 'B', mode = 'lines',
line = list(color = 'green'))
fig1
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, L0=1, A0=1, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/((L0)^(lambda)) # exclude sR from initial calc
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
LA_time <- 1/z_time
gA <- theta/z_time
L_time <- L0*exp(gL*u)
lnA_time <- lambda*log(sR)/(1-phi) + log(z_time)/(1-phi) + lambda*log(L_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "L" = L_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "L_init" = L0, "A_init" = A0)
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
r <- f.romer(t = seq(from = 1,to = 1000, by = 1))
s <- f.romer(t = seq(from = 1,to = 1000, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.002)
fig1 <- plot_ly(r, x = ~time, y = ~gA, type = 'scatter', mode = 'lines', name='A')
fig1 <- fig1 %>% add_trace(x = ~time, y = ~gA, data = s, name = 'B', mode = 'lines',
line = list(color = 'green'))
fig1
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, L0=1, A0=.02, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/((L0)^(lambda)) # exclude sR from initial calc
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
LA_time <- 1/z_time
gA <- theta/z_time
L_time <- L0*exp(gL*u)
lnA_time <- lambda*log(sR)/(1-phi) + log(z_time)/(1-phi) + lambda*log(L_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "L" = L_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "L_init" = L0, "A_init" = A0)
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
r <- f.romer(t = seq(from = 1,to = 1000, by = 1))
s <- f.romer(t = seq(from = 1,to = 1000, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.002)
fig1 <- plot_ly(r, x = ~time, y = ~gA, type = 'scatter', mode = 'lines', name='A')
fig1 <- fig1 %>% add_trace(x = ~time, y = ~gA, data = s, name = 'B', mode = 'lines',
line = list(color = 'green'))
fig1
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, L0=1, A0=.02, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/((L0)^(lambda)) # exclude sR from initial calc
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
gA <- theta*sR^(lambda)/z_time
L_time <- L0*exp(gL*u)
lnA_time <- lambda*log(sR)/(1-phi) + log(z_time)/(1-phi) + lambda*log(L_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "L" = L_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "L_init" = L0, "A_init" = A0)
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
r <- f.romer(t = seq(from = 1,to = 1000, by = 1))
s <- f.romer(t = seq(from = 1,to = 1000, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.002)
fig1 <- plot_ly(r, x = ~time, y = ~gA, type = 'scatter', mode = 'lines', name='A')
fig1 <- fig1 %>% add_trace(x = ~time, y = ~gA, data = s, name = 'B', mode = 'lines',
line = list(color = 'green'))
fig1
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, L0=1, A0=.02, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/((L0)^(lambda)) # exclude sR from initial calc
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
gA <- theta*sR^(lambda)/z_time
L_time <- L0*exp(gL*u)
lnA_time <- lambda*log(sR)/(1-phi) + log(z_time)/(1-phi) + lambda*log(L_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "L" = L_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "L_init" = L0, "A_init" = A0)
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
r <- f.romer(t = seq(from = 1,to = 1000, by = 1))
s <- f.romer(t = seq(from = 1,to = 1000, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.002)
fig1 <- plot_ly(r, x = ~time, y = ~lnA, type = 'scatter', mode = 'lines', name='A')
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = s, name = 'B', mode = 'lines',
line = list(color = 'green'))
fig1
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, L0=1, A0=.02, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/((L0)^(lambda)) # exclude sR from initial calc
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
gA <- theta*sR^(lambda)/z_time
L_time <- L0*exp(gL*u)
lnA_time <- lambda*log(sR)/(1-phi) + log(z_time)/(1-phi) + lambda*log(L_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "L" = L_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "L_init" = L0, "A_init" = A0)
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
r <- f.romer(t = seq(from = 1,to = 1000, by = 1))
s <- f.romer(t = seq(from = 1,to = 1000, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.002)
w <- f.romer(t = seq(from = 1,to = 1000, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.02)
fig1 <- plot_ly(r, x = ~time, y = ~lnA, type = 'scatter', mode = 'lines', name='A')
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = s, name = 'B', mode = 'lines',
line = list(color = 'green'))
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = w, name = 'C', mode = 'lines',
line = list(color = 'red'))
fig1
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, L0=1, A0=.02, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/((L0)^(lambda)) # exclude sR from initial calc
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
gA <- theta*sR^(lambda)/z_time
L_time <- L0*exp(gL*u)
lnA_time <- lambda*log(sR)/(1-phi) + log(z_time)/(1-phi) + lambda*log(L_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "L" = L_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "L_init" = L0, "A_init" = A0)
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
r <- f.romer(t = seq(from = 1,to = 1000, by = 1))
s <- f.romer(t = seq(from = 1,to = 1000, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.002)
w <- f.romer(t = seq(from = 1,to = 1000, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.02)
x <- f.romer(t = seq(from = 1,to = 1000, by = 1),A0 = r$A_init, L0 = r$L_init*2)
fig1 <- plot_ly(r, x = ~time, y = ~lnA, type = 'scatter', mode = 'lines', name='A')
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = s, name = 'B', mode = 'lines',
line = list(color = 'green'))
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = w, name = 'C', mode = 'lines',
line = list(color = 'red'))
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = x, name = 'D', mode = 'lines',
line = list(color = 'purple'))
fig1
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, L0=1, A0=.02, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/((L0)^(lambda)) # exclude sR from initial calc
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
gA <- theta*sR^(lambda)/z_time
L_time <- L0*exp(gL*u)
lnA_time <- lambda*log(sR)/(1-phi) + log(z_time)/(1-phi) + lambda*log(L_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "L" = L_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "L_init" = L0, "A_init" = A0)
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
r <- f.romer(t = seq(from = 1,to = 400, by = 1))
s <- f.romer(t = seq(from = 1,to = 400, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.002)
w <- f.romer(t = seq(from = 1,to = 400, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.02)
x <- f.romer(t = seq(from = 1,to = 400, by = 1),A0 = r$A_init, L0 = r$L_init*4)
fig1 <- plot_ly(r, x = ~time, y = ~lnA, type = 'scatter', mode = 'lines', name='A')
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = s, name = 'B', mode = 'lines',
line = list(color = 'green'))
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = w, name = 'C', mode = 'lines',
line = list(color = 'red'))
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = x, name = 'D', mode = 'lines',
line = list(color = 'purple'))
fig1
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, L0=1, A0=.02, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/((L0)^(lambda)) # exclude sR from initial calc
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
gA <- theta*sR^(lambda)/z_time
L_time <- L0*exp(gL*u)
lnA_time <- lambda*log(sR)/(1-phi) + log(z_time)/(1-phi) + lambda*log(L_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "L" = L_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "L_init" = L0, "A_init" = A0)
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
A <- f.romer(t = seq(from = 1,to = 400, by = 1))
B <- f.romer(t = seq(from = 1,to = 400, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.002)
C <- f.romer(t = seq(from = 1,to = 400, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.02)
D <- f.romer(t = seq(from = 1,to = 400, by = 1),A0 = r$A_init, L0 = r$L_init*4)
E <- f.romer(t = seq(from = 1,to = 400, by = 1),A0 = r$A_init, L0 = r$L_init*.25)
fig1 <- plot_ly(A, x = ~time, y = ~lnA, type = 'scatter', mode = 'lines', name='A')
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = B, name = 'B', mode = 'lines',
line = list(color = 'green'))
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = C, name = 'C', mode = 'lines',
line = list(color = 'red'))
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = D, name = 'D', mode = 'lines',
line = list(color = 'purple'))
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = E, name = 'D', mode = 'lines',
line = list(color = 'orange'))
fig1
## Set up and plot hypothetical paths of productivity process
f.romer <- function(theta = .01, lambda=1, phi=0, sR=.02, gL=.01, L0=1, A0=.02, t=1) {
# z is A^1-phi/R^lambda state variable, solved for first, then extract info
z_init <- A0^(1-phi)/((L0)^(lambda)) # exclude sR from initial calc
z_ss <- (1-phi)*theta*sR^(lambda)/(lambda*gL)
# Manage time periods passed
u <- tryCatch(
{u = t - min(t)}, # reset any list of time periods to start at zero, for convergence calcs
error=function(cond) { # if above fails, just take t as-is (usually a single number)
return(t)
}
)
conv <- lambda*gL # convergence parameter
z_time <- exp(-1*conv*u)*z_init + (1-exp(-1*conv*u))*z_ss
gA <- theta*sR^(lambda)/z_time
L_time <- L0*exp(gL*u)
lnA_time <- lambda*log(sR)/(1-phi) + log(z_time)/(1-phi) + lambda*log(L_time)/(1-phi)
# create list containing all results
results <- list("time" = t, "z" = z_time, "L" = L_time, "lnA" = lnA_time, "gA" = gA,
"z_ss" = z_ss, "L_init" = L0, "A_init" = A0)
solved <- as.data.frame(results) # convert to data frame to pass back
return(solved) # return all results
}
A <- f.romer(t = seq(from = 1,to = 400, by = 1))
B <- f.romer(t = seq(from = 1,to = 400, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.002)
C <- f.romer(t = seq(from = 1,to = 400, by = 1),A0 = r$A_init, L0 = r$L_init,gL = 0.015)
D <- f.romer(t = seq(from = 1,to = 400, by = 1),A0 = r$A_init, L0 = r$L_init*4)
E <- f.romer(t = seq(from = 1,to = 400, by = 1),A0 = r$A_init, L0 = r$L_init*.25)
fig1 <- plot_ly(A, x = ~time, y = ~lnA, type = 'scatter', mode = 'lines', name='A')
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = B, name = 'B', mode = 'lines',
line = list(color = 'green'))
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = C, name = 'C', mode = 'lines',
line = list(color = 'red'))
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = D, name = 'D', mode = 'lines',
line = list(color = 'purple'))
fig1 <- fig1 %>% add_trace(x = ~time, y = ~lnA, data = E, name = 'D', mode = 'lines',
line = list(color = 'orange'))
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Prod.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Prod.r")
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Prod.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Prod.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Prod.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Prod.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Prod.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Prod.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Prod.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Prod.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Prod.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Prod.r")
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Prod.r")
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Resource_Model.r")
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Resource_Model.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Resource_Model.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Resource_Model.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Resource_Model.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Resource_Model.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Resource_Model.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Resource_Model.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Resource_Model.r")
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Resource_Model.r")
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Resource_Model.r")
fig1
source("~/Library/CloudStorage/Dropbox/Project/StudyGuide/code/Guide_Sim_Resource_Model.r")
fig1
